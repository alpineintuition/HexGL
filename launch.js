// Generated by CoffeeScript 1.7.1
const URL = "/home/jkr/Development/BUSINESS/AlpineIntuition/games/my_model/";

let model, webcam, labelContainer, maxPredictions;
let poseNet = false;


(function() {
  var $, a, defaultControls, getWebGL, hasWebGL, init, s, u, _fn, _i, _len;

  $ = function(_) {
    return document.getElementById(_);
  };

// Load the image model and setup the webcam
init_boom = async function () {
    const modelURL = URL + "model.json";
    const metadataURL = URL + "metadata.json";

    // load the model and metadata
    // Refer to tmImage.loadFromFiles() in the API to support files from a file picker
    // or files from your local hard drive
    // Note: the pose library adds "tmImage" object to your window (window.tmImage)
    const uploadModel = document.getElementById('upload-model');
    const uploadWeights = document.getElementById('upload-weights');
    const uploadMetadata = document.getElementById('upload-metadata');

    if(poseNet){
      model = await tmPose.loadFromFiles(uploadModel.files[0], uploadWeights.files[0], uploadMetadata.files[0])
    }
    else{
      model = await tmImage.loadFromFiles(uploadModel.files[0], uploadWeights.files[0], uploadMetadata.files[0])
    }
    
    

    maxPredictions = model.getTotalClasses();

    // Convenience function to setup a webcam
    const size = 150;
    const flip = true; // whether to flip the webcam
    if(poseNet){
      webcam = new tmPose.Webcam(size, size, flip)
    }
    else{
      webcam = new tmImage.Webcam(size, size, flip); // width, height, flip
    }
    await webcam.setup(); // request access to the webcam
    await webcam.play();
    window.requestAnimationFrame(loop_teachable);

    // append elements to the DOM
    document.getElementById("webcam-container").appendChild(webcam.canvas);
    labelContainer = document.getElementById("label-container");
    for (let i = 0; i < maxPredictions; i++) { // and class labels
        labelContainer.appendChild(document.createElement("div"));
    }
}

async function loop_teachable() {
    webcam.update(); // update the webcam frame
    await predict();
    setTimeout(function(){ window.requestAnimationFrame(loop_teachable) }, 100);
}
// run the webcam image through the image model
async function predict() {
    // predict can take in an image, video or canvas html element
    // Prediction #1: run input through posenet
    // estimatePose can take in an image, video or canvas html element
    let prediction;
    if(poseNet){
      const { pose, posenetOutput } = await model.estimatePose(webcam.canvas);
      // Prediction 2: run input through teachable machine classification model
      prediction = await model.predict(posenetOutput);
    }
    else{
      prediction = await model.predict(webcam.canvas);
    }
    let max_id=-1;
    let max_value=0;
    for (let i = 0; i < maxPredictions; i++) {
        const classPrediction =
            prediction[i].className + ": " + prediction[i].probability.toFixed(2);
        labelContainer.childNodes[i].innerHTML = classPrediction;
        if(prediction[i].probability > max_value){
            max_value = prediction[i].probability;
            max_id = i;
        }
    }
    if(window.hexGL !== undefined){
      switch(max_id){
        case 0: /*left*/
          window.hexGL.gameplay.shipControls.key.forward = true;
          window.hexGL.gameplay.shipControls.key.left = true;
          window.hexGL.gameplay.shipControls.key.right = false;
          break;
        case 1: /*right*/
          window.hexGL.gameplay.shipControls.key.forward = true;
          window.hexGL.gameplay.shipControls.key.right = true;
          window.hexGL.gameplay.shipControls.key.left = false;
          break;
        case 2: /*straight*/
          window.hexGL.gameplay.shipControls.key.forward = true;
          window.hexGL.gameplay.shipControls.key.left = false;
          window.hexGL.gameplay.shipControls.key.right = false;
          break;
        case 3:
          window.hexGL.gameplay.shipControls.key.forward = false;
          window.hexGL.gameplay.shipControls.key.left = false;
          window.hexGL.gameplay.shipControls.key.right = false;
          break;
      }
    }

}

init_star = function(){
  return init(s[0][3], s[1][0], s[2][3], s[3][3]);
}

  init = function(controlType, quality, hud, godmode) {
    var hexGL, progressbar;
    hexGL = new bkcore.hexgl.HexGL({
      document: document,
      width: window.innerWidth,
      height: window.innerHeight,
      container: $('main'),
      overlay: $('overlay'),
      gameover: $('step-5'),
      quality: quality,
      difficulty: 0,
      hud: hud === 1,
      controlType: controlType,
      godmode: godmode,
      track: 'Cityscape'
    });
    window.hexGL = hexGL;
    progressbar = $('progressbar');
    return hexGL.load({
      onLoad: function() {
        console.log('LOADED.');
        hexGL.init();
        $('step-3').style.display = 'none';
        $('step-4').style.display = 'block';
        return hexGL.start();
      },
      onError: function(s) {
        return console.error("Error loading " + s + ".");
      },
      onProgress: function(p, t, n) {
        console.log("LOADED " + t + " : " + n + " ( " + p.loaded + " / " + p.total + " ).");
        return progressbar.style.width = "" + (p.loaded / p.total * 100) + "%";
      }
    });
  };

  u = bkcore.Utils.getURLParameter;

  defaultControls = bkcore.Utils.isTouchDevice() ? 1 : 0;

  s = [['controlType', ['KEYBOARD', 'TOUCH', 'LEAP MOTION CONTROLLER', 'GAMEPAD'], defaultControls, defaultControls, 'Controls: '], ['quality', ['LOW', 'MID', 'HIGH', 'VERY HIGH'], 3, 3, 'Quality: '], ['hud', ['OFF', 'ON'], 1, 1, 'HUD: '], ['godmode', ['OFF', 'ON'], 0, 1, 'Godmode: ']];

  _fn = function(a) {
    var e, f, _ref;
    a[3] = (_ref = u(a[0])) != null ? _ref : a[2];
    e = $("s-" + a[0]);
    (f = function() {
      return e.innerHTML = a[4] + a[1][a[3]];
    })();
    return e.onclick = function() {
      return f(a[3] = (a[3] + 1) % a[1].length);
    };
  };
  for (_i = 0, _len = s.length; _i < _len; _i++) {
    a = s[_i];
    _fn(a);
  }

  $('step-2').onclick = function() {
    $('step-2').style.display = 'none';
    $('step-3').style.display = 'block';
    return init(s[0][3], s[1][3], s[2][3], s[3][3]);
  };

  $('step-5').onclick = function() {
    return window.location.reload();
  };

  $('s-credits').onclick = function() {
    $('step-1').style.display = 'none';
    return $('credits').style.display = 'block';
  };

  $('credits').onclick = function() {
    $('step-1').style.display = 'block';
    return $('credits').style.display = 'none';
  };

  hasWebGL = function() {
    var canvas, gl;
    gl = null;
    canvas = document.createElement('canvas');
    try {
      gl = canvas.getContext("webgl");
    } catch (_error) {}
    if (gl == null) {
      try {
        gl = canvas.getContext("experimental-webgl");
      } catch (_error) {}
    }
    return gl != null;
  };

  if (!hasWebGL()) {
    getWebGL = $('start');
    getWebGL.innerHTML = 'WebGL is not supported!';
    getWebGL.onclick = function() {
      return window.location.href = 'http://get.webgl.org/';
    };
  } else {
    $('step-1').style.display = 'none';
    $('step-2').style.display = 'none';
    $('step-3').style.display = 'none';
    // $('start').onclick = function() {
    //   $('step-1').style.display = 'none';
    //   $('step-2').style.display = 'block';
    //   return $('step-2').style.backgroundImage = "url(css/help-" + s[0][3] + ".png)";
    // };
  }

}).call(this);

